<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>Trabalho 1: Gear Up!</title>
    <style>
        body { font-family: sans-serif; text-align: center; background-color: #f0f0f0; margin: 0; padding: 20px; }
        canvas { border: 2px solid black; background-color: white; cursor: default; }
        #controles { margin: 15px 0; }
        button { font-size: 16px; padding: 10px 20px; cursor: pointer; }
        #infoClique { font-size: 1.1em; font-weight: bold; color: #333; }
    </style>
</head>
<body>

    <h1>Trabalho 1: Gear Up!</h1>
    <p><b>Instruções:</b> Clique e arraste os vértices (bolinhas) para remodelar as formas. <br> Clique e arraste o corpo de uma forma para movê-la.</p>
    
    <canvas id="canvasInterativo" width="800" height="600"></canvas>
    
    <div id="controles">
        <button onclick="exportarLog()">Exportar Log como CSV</button>
        <p id="infoClique">Objeto selecionado: Nenhum</p>
    </div>

<script>
    // --- Configurações Iniciais ---
    const canvas = document.getElementById('canvasInterativo');
    const ctx = canvas.getContext('2d');
    const infoCliqueElemento = document.getElementById('infoClique');

    const startTime = Date.now();
    let logDados = [];
    let contadorCliques = 0;

    // Estado para controlar o arraste (drag and drop)
    let estadoDrag = {
        arrastando: false,
        formaSelecionada: null,
        verticeSelecionado: null,
        offsetX: 0,
        offsetY: 0
    };

    // --- CLASSES PARA ORIENTAÇÃO A OBJETOS ---

    class Poligono {
        constructor(nome, pontos, cores) {
            this.nome = nome;
            this.pontos = pontos; // [{x, y}, {x, y}, ...]
            this.cores = cores;   // {area, linha, ponto}
        }

        desenhar() {
            // Área
            ctx.fillStyle = this.cores.area;
            ctx.beginPath();
            ctx.moveTo(this.pontos[0].x, this.pontos[0].y);
            for (let i = 1; i < this.pontos.length; i++) {
                ctx.lineTo(this.pontos[i].x, this.pontos[i].y);
            }
            ctx.closePath();
            ctx.fill();

            // Linha
            ctx.strokeStyle = this.cores.linha;
            ctx.lineWidth = 3;
            ctx.stroke();

            // Pontos (Vértices)
            this.desenharVertices();
        }
        
        desenharVertices() {
             ctx.fillStyle = this.cores.ponto;
             for (const ponto of this.pontos) {
                ctx.beginPath();
                ctx.arc(ponto.x, ponto.y, 7, 0, 2 * Math.PI);
                ctx.fill();
            }
        }

        pontoEstaDentro(x, y) {
            // Usa a API do Canvas para verificação
            ctx.beginPath();
            ctx.moveTo(this.pontos[0].x, this.pontos[0].y);
            for (let i = 1; i < this.pontos.length; i++) {
                ctx.lineTo(this.pontos[i].x, this.pontos[i].y);
            }
            ctx.closePath();
            return ctx.isPointInPath(x, y);
        }

        getVerticeProximo(x, y, tolerancia = 10) {
            for (let i = 0; i < this.pontos.length; i++) {
                const p = this.pontos[i];
                const dist = Math.sqrt((p.x - x)**2 + (p.y - y)**2);
                if (dist <= tolerancia) {
                    return i; // Retorna o índice do vértice
                }
            }
            return null; // Nenhum vértice próximo
        }
    }

    class Linha {
        constructor(nome, pontoA, pontoB, cor) {
            this.nome = nome;
            this.pontoA = pontoA;
            this.pontoB = pontoB;
            this.cor = cor;
        }

        desenhar() {
            // Desenha a linha
            ctx.strokeStyle = this.cor;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(this.pontoA.x, this.pontoA.y);
            ctx.lineTo(this.pontoB.x, this.pontoB.y);
            ctx.stroke();
            
            // Desenha os pontos nas extremidades
            ctx.fillStyle = this.cor;
            ctx.beginPath();
            ctx.arc(this.pontoA.x, this.pontoA.y, 7, 0, 2 * Math.PI);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(this.pontoB.x, this.pontoB.y, 7, 0, 2 * Math.PI);
            ctx.fill();
        }

        pontoEstaDentro(x, y, tolerancia = 10) {
            // Detecção de clique na linha (simplificado)
            return this.getVerticeProximo(x, y) !== null;
        }

        getVerticeProximo(x, y, tolerancia = 10) {
            const distA = Math.sqrt((this.pontoA.x - x)**2 + (this.pontoA.y - y)**2);
            if(distA <= tolerancia) return 'A';
            const distB = Math.sqrt((this.pontoB.x - x)**2 + (this.pontoB.y - y)**2);
            if(distB <= tolerancia) return 'B';
            return null;
        }
    }
     class Ponto {
        constructor(nome, ponto, cor) {
            this.nome = nome;
            this.ponto = ponto;
            this.cor = cor;
        }

        desenhar() {
            ctx.fillStyle = this.cor;
            ctx.beginPath();
            ctx.arc(this.ponto.x, this.ponto.y, 8, 0, 2 * Math.PI);
            ctx.fill();
        }

        pontoEstaDentro(x, y, tolerancia = 10) {
             const dist = Math.sqrt((this.ponto.x - x)**2 + (this.ponto.y - y)**2);
             return dist <= tolerancia;
        }
         
        getVerticeProximo(x, y, tolerancia = 10) {
             return this.pontoEstaDentro(x, y, tolerancia) ? 0 : null;
        }
    }


    // --- CRIAÇÃO DOS OBJETOS ---
    const formas = [
        new Poligono(
            "Triangulo", 
            [{x: 150, y: 400}, {x: 350, y: 100}, {x: 100, y: 250}],
            {area: 'rgba(173, 216, 230, 0.7)', linha: 'blue', ponto: 'red'}
        ),
        new Poligono(
            "Quadrilatero",
            [{x: 500, y: 150}, {x: 700, y: 200}, {x: 650, y: 450}, {x: 450, y: 400}],
            {area: 'rgba(221, 160, 221, 0.7)', linha: 'purple', ponto: 'green'}
        ),
        new Linha("Linha_Isolada", {x: 50, y: 50}, {x: 250, y: 80}, 'orange'),
        new Ponto("Ponto_Isolado", {x: 700, y: 550}, 'black')
    ];

    function desenharTudo() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        for (const forma of formas) {
            forma.desenhar();
        }
    }

    // --- EVENT LISTENERS PARA INTERATIVIDADE ---

    canvas.addEventListener('mousedown', (e) => {
        const {x, y} = getMousePos(e);
        
        contadorCliques++;
        let objetoClicado = "Nenhum objeto";

        // Itera de trás para frente (para pegar o objeto de cima primeiro)
        for (let i = formas.length - 1; i >= 0; i--) {
            const forma = formas[i];
            const vertice = forma.getVerticeProximo(x, y);
            
            if (vertice !== null) {
                estadoDrag.arrastando = true;
                estadoDrag.formaSelecionada = forma;
                estadoDrag.verticeSelecionado = vertice;
                objetoClicado = `${forma.nome} (vértice)`;
                break;
            } else if (forma.pontoEstaDentro(x, y)) {
                estadoDrag.arrastando = true;
                estadoDrag.formaSelecionada = forma;
                estadoDrag.verticeSelecionado = null; // Arrastando a forma inteira
                estadoDrag.offsetX = x;
                estadoDrag.offsetY = y;
                objetoClicado = forma.nome;
                break;
            }
        }
        
        infoCliqueElemento.textContent = `Objeto selecionado: ${objetoClicado}`;
        logClique(x, y, objetoClicado);
        desenharTudo();
    });

    canvas.addEventListener('mousemove', (e) => {
        const {x, y} = getMousePos(e);
        logMovimento(x, y);

        if (!estadoDrag.arrastando) {
             // Lógica para mudar o cursor (feedback visual)
            document.body.style.cursor = 'default';
            for (const forma of formas) {
                 if(forma.getVerticeProximo(x,y) !== null || forma.pontoEstaDentro(x,y)) {
                     document.body.style.cursor = 'pointer';
                     break;
                 }
            }
            return;
        }

        document.body.style.cursor = 'grabbing';
        const forma = estadoDrag.formaSelecionada;

        if (estadoDrag.verticeSelecionado !== null) {
            // Arrastando um vértice
            if (forma instanceof Poligono) {
                forma.pontos[estadoDrag.verticeSelecionado] = {x, y};
            } else if (forma instanceof Linha) {
                if(estadoDrag.verticeSelecionado === 'A') forma.pontoA = {x, y};
                else forma.pontoB = {x, y};
            } else if (forma instanceof Ponto) {
                forma.ponto = {x, y};
            }
        } else {
            // Arrastando a forma inteira
            const dx = x - estadoDrag.offsetX;
            const dy = y - estadoDrag.offsetY;
            
            if (forma.pontos) { // Poligono
                 forma.pontos.forEach(p => { p.x += dx; p.y += dy; });
            } else if (forma.pontoA) { // Linha
                 forma.pontoA.x += dx; forma.pontoA.y += dy;
                 forma.pontoB.x += dx; forma.pontoB.y += dy;
            } else if (forma.ponto) { // Ponto
                 forma.ponto.x += dx; forma.ponto.y += dy;
            }
            
            estadoDrag.offsetX = x;
            estadoDrag.offsetY = y;
        }

        desenharTudo();
    });

    canvas.addEventListener('mouseup', (e) => {
        estadoDrag.arrastando = false;
        estadoDrag.formaSelecionada = null;
        estadoDrag.verticeSelecionado = null;
        document.body.style.cursor = 'default';
    });
     canvas.addEventListener('mouseout', (e) => { // Para o arraste se o mouse sair da tela
        estadoDrag.arrastando = false;
        document.body.style.cursor = 'default';
    });


    // --- Funções Auxiliares e de Log ---
    function getMousePos(evt) {
        const rect = canvas.getBoundingClientRect();
        return {
            x: evt.clientX - rect.left,
            y: evt.clientY - rect.top
        };
    }

    function logMovimento(x, y) {
        logDados.push({
            timestamp: ((Date.now() - startTime) / 1000).toFixed(2), 
            evento: 'movimento', x: x.toFixed(0), y: y.toFixed(0), objeto_clicado: 'N/A'
        });
    }

    function logClique(x, y, objeto) {
         logDados.push({
            timestamp: ((Date.now() - startTime) / 1000).toFixed(2), 
            evento: 'clique', x: x.toFixed(0), y: y.toFixed(0), objeto_clicado: objeto
        });
    }

    function exportarLog() {
        if(logDados.length === 0){
            alert("Nenhuma interação registrada para exportar.");
            return;
        }
        const tempoExecucao = ((Date.now() - startTime) / 1000).toFixed(2);
        let csvContent = "data:text/csv;charset=utf-8,";
        csvContent += "timestamp,evento,x,y,objeto_clicado,total_cliques,tempo_total_execucao\n";
        logDados.forEach(log => {
            csvContent += `${log.timestamp},${log.evento},${log.x},${log.y},"${log.objeto_clicado}",${contadorCliques},${tempoExecucao}\n`;
        });
        const encodedUri = encodeURI(csvContent);
        const link = document.createElement("a");
        link.setAttribute("href", encodedUri);
        link.setAttribute("download", "log_interacao.csv");
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        alert("Log exportado com sucesso!");
    }

    // --- Início ---
    desenharTudo();
</script>

</body>
</html>